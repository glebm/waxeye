{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 802b00591e9908ec02af","webpack:///./cons_list.ts","webpack:///./waxeye.ts","webpack:///./expr.ts"],"names":[],"mappings":"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","file":"./dist/waxeye.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"waxeye\"] = factory();\n\telse\n\t\troot[\"waxeye\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 802b00591e9908ec02af","// A type-safe immutable homogenous \"persistent\" cons list.\n// A cons list is either empty or a cons pair of T and a cons list.\nexport type ConsList<T> = Cons<T>|Empty;\n\n// Creates a non-empty cons list.\nexport function cons<T>(head: T, tail: ConsList<T>): Cons<T> {\n  return new Cons<T>(head, tail);\n}\n\n// Returns the empty cons list.\nexport function empty(): Empty {\n  return Empty.instance;\n}\n\n// Methods implemented by both Empty and Cons<T>.\nexport interface ConsListInterface<T> extends Iterable<T> {\n  // Check whether the list is an Empty.\n  //\n  // Using this method is preferable to the expensive and less readable\n  // `instanceof Empty` check.\n  isEmpty(): this is Empty;\n\n  // Equivalent to [...list] but slightly faster.\n  toArray(): T[];\n}\n\n// A non-empty cons list.\nexport class Cons<T> implements ConsListInterface<T> {\n  // Internal, not public.\n  // TODO(glebm): Add the internal modifier once it's implemented in TypeScript\n  // https://github.com/Microsoft/TypeScript/issues/5228\n  constructor(public readonly head: T, public readonly tail: ConsList<T>) {}\n\n  public isEmpty(): this is Empty {\n    return false;\n  }\n\n  public toArray(): T[] {\n    const result: T[] = [this.head];\n    let currentTail = this.tail;\n    while (!currentTail.isEmpty()) {\n      result.push(currentTail.head);\n      currentTail = currentTail.tail;\n    }\n    return result;\n  }\n\n  public[Symbol.iterator](): Iterator<T> {\n    let current: ConsList<T> = this;\n    return {\n      next(): IteratorResult<T> {\n        if (current.isEmpty()) {\n          // This typecast is necessary because TypeScript incorrectly\n          // specifies both `done` and `value` as required.\n          return {done: true} as IteratorResult<T>;\n        }\n        const value = current.head;\n        current = current.tail;\n        return {value} as IteratorResult<T>;\n      },\n    };\n  }\n}\n\n// An empty cons list.\nexport class Empty implements ConsListInterface<never> {\n  public static readonly instance = new Empty();\n  private constructor() {}\n  public isEmpty(): this is Empty {\n    return true;\n  }\n  public toArray(): never[] {\n    return [];\n  }\n  public[Symbol.iterator](): Iterator<never> {\n    return {\n      next(): IteratorResult<never> {\n        return {done: true} as IteratorResult<never>;\n      },\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./cons_list.ts","/*\n * Waxeye Parser Generator http://www.waxeye.org\n * Licensed under the MIT license. See 'LICENSE' for details.\n */\n\nimport {cons, ConsList, empty} from './cons_list';\nimport {Expr, exprToRuntimeExpr, ExprType, RuntimeExpr} from './expr';\n\nexport {Expr, ExprType} from './expr';\n\nexport class WaxeyeParser {\n  private readonly env: RuntimeParserConfig;\n  public constructor(\n      public readonly config: ParserConfig,\n      public readonly start: keyof ParserConfig /* keyof env */) {\n    this.env = parserConfigToRuntimeParserConfig(config);\n  }\n\n  public parse(input: string, start: string = this.start): AST|ParseError {\n    if (!this.env[start]) {\n      throw new Error(`Invalid non-terminal ${start}. Expected one of: ${\n          Object.keys(this.env).join(', ')}`);\n    }\n    return match(this.env, start, input);\n  }\n}\n\nexport interface ParserConfig {\n  // name -> ParserConfigNonTerminal\n  [key: string]: {mode: NonTerminalMode, exp: Expr};\n}\ninterface RuntimeParserConfig {\n  // name -> ParserConfigNonTerminal\n  [key: string]: {mode: NonTerminalMode, exp: RuntimeExpr};\n}\n\nfunction parserConfigToRuntimeParserConfig(config: ParserConfig):\n    RuntimeParserConfig {\n  const result: RuntimeParserConfig = {};\n  for (const [name, nonterminal] of Object.entries(config)) {\n    result[name] = {\n      mode: nonterminal.mode,\n      exp: exprToRuntimeExpr(nonterminal.exp),\n    };\n  }\n  return result;\n}\n\nexport const enum NonTerminalMode {\n  NORMAL = 1,\n  PRUNING,\n  VOIDING,\n}\n\n/*\n * An abstract syntax tree holds the non-terminal's name (`type`),\n * and a list of child ASTs.\n */\nexport class AST {\n  constructor(public type: string, public children: Array<AST|string>) {}\n\n  /**\n   * The empty AST is an AST that has an empty `type` and no children.\n   */\n  public isEmpty(): this is EmptyAST {\n    return this.type === '' && this.children.length === 0;\n  }\n}\n\nexport interface EmptyAST extends AST {\n  type: '';\n  children: never[];\n}\n\nexport function EmptyAST(): EmptyAST {\n  return new AST('', []) as EmptyAST;\n}\n\nexport interface MatchError {\n  // Expected expression in the grammar format.\n  toGrammarString(): string;\n}\n\n// A failed single character match.\nexport class ErrChar implements MatchError {\n  constructor(public char: string) {}\n\n  public toGrammarString() {\n    return `'${JSON.stringify(this.char).slice(1, -1)}'`;\n  }\n}\n\n// A failed character class match.\nexport class ErrCC implements MatchError {\n  // A list of Unicode codepoints / ranges of codepoints.\n  constructor(public charClasses: Array<number|[number, number]>) {}\n\n  public toGrammarString() {\n    return `[${\n        this.charClasses\n            .map((charClass) => {\n              return JSON\n                  .stringify(\n                      typeof charClass === 'number' ?\n                          String.fromCodePoint(charClass) :\n                          `${String.fromCodePoint(charClass[0])}-${\n                              String.fromCodePoint(charClass[1])}`)\n                  .slice(1, -1);\n            })\n            .join('')}]`;\n  }\n}\n\n// A failed wildcard match.\nexport class ErrAny implements MatchError {\n  public toGrammarString() {\n    return '.';\n  }\n}\n\nexport class ParseError {\n  constructor(\n      public pos: number, public line: number, public col: number,\n      public nt: string[], public chars: MatchError[]) {}\n\n  public toString(): string {\n    const chars =\n        this.chars.map((err) => err.toGrammarString()).join(' | ') || '\\'\\'';\n    return `Parse error: Failed to match '${this.nt.join(',')}' at line=${\n        this.line}, col=${this.col}, pos=${this.pos}. Expected: ${chars}`;\n  }\n}\nclass RawError {\n  constructor(\n      public pos: number, public nonterminals: ConsList<string>,\n      public failedChars: ConsList<MatchError>, public currentNT: string) {}\n\n  public toParseError(input: string): ParseError {\n    const [line, col] = getLineCol(this.pos, input);\n    const uniqueNonterminals: string[] = [];\n    const seenNonterminals = new Set<string>();\n    for (const nt of this.nonterminals) {\n      if (seenNonterminals.has(nt)) {\n        continue;\n      }\n      uniqueNonterminals.push(nt);\n      seenNonterminals.add(nt);\n    }\n    return new ParseError(\n        this.pos, line, col, uniqueNonterminals,\n        this.failedChars.toArray().reverse());\n  }\n}\n\nfunction updateError(err: RawError, pos: number, e: MatchError): RawError {\n  if (err !== null) {\n    if (pos > err.pos) {\n      return new RawError(\n          pos, cons(err.currentNT, empty()), cons(e, empty()), err.currentNT);\n    } else if (pos === err.pos) {\n      return new RawError(\n          err.pos, cons(err.currentNT, err.nonterminals),\n          cons(e, err.failedChars), err.currentNT);\n    } else {\n      return new RawError(\n          err.pos, err.nonterminals, err.failedChars, err.currentNT);\n    }\n  } else {\n    return new RawError(0, cons('', empty()), cons(e, empty()), '');\n  }\n}\n\ntype ASTList = ConsList<AST|string>;\n\ntype Continuation =\n    ContSeq|ContAlt|ContAnd|ContNot|ContOpt|ContStar|ContPlus|ContVoid|ContNT;\n\nconst enum ContType {\n  SEQ = 1,\n  ALT,\n  AND,\n  NOT,\n  OPT,\n  STAR,\n  PLUS,\n  VOID,\n  NT,\n}\n\ninterface ContSeq {\n  type: ContType.SEQ;\n  expressions: ConsList<RuntimeExpr>;\n}\nfunction contSeq(expressions: ConsList<RuntimeExpr>): ContSeq {\n  return {type: ContType.SEQ, expressions};\n}\n\ninterface ContAlt {\n  type: ContType.ALT;\n  expressions: ConsList<RuntimeExpr>;\n  pos: number;\n  asts: ASTList;\n}\nfunction contAlt(\n    expressions: ConsList<RuntimeExpr>, pos: number, asts: ASTList): ContAlt {\n  return {type: ContType.ALT, expressions, pos, asts};\n}\n\ninterface ContAnd {\n  type: ContType.AND;\n  pos: number;\n  asts: ASTList;\n  err: RawError;\n}\nfunction contAnd(pos: number, asts: ASTList, err: RawError): ContAnd {\n  return {type: ContType.AND, pos, asts, err};\n}\n\ninterface ContNot {\n  type: ContType.NOT;\n  pos: number;\n  asts: ASTList;\n  err: RawError;\n}\nfunction contNot(pos: number, asts: ASTList, err: RawError): ContNot {\n  return {type: ContType.NOT, pos, asts, err};\n}\n\ninterface ContOpt {\n  type: ContType.OPT;\n  pos: number;\n  asts: ASTList;\n}\nfunction contOpt(pos: number, asts: ASTList): ContOpt {\n  return {type: ContType.OPT, pos, asts};\n}\n\ninterface ContStar {\n  type: ContType.STAR;\n  expression: RuntimeExpr;\n  pos: number;\n  asts: ASTList;\n}\nfunction contStar(\n    expression: RuntimeExpr, pos: number, asts: ASTList): ContStar {\n  return {type: ContType.STAR, expression, pos, asts};\n}\n\ninterface ContPlus {\n  type: ContType.PLUS;\n  expression: RuntimeExpr;\n}\nfunction contPlus(expression: RuntimeExpr): ContPlus {\n  return {type: ContType.PLUS, expression};\n}\n\ninterface ContVoid {\n  type: ContType.VOID;\n  asts: ASTList;\n}\nfunction contVoid(asts: ASTList): ContVoid {\n  return {type: ContType.VOID, asts};\n}\n\ninterface ContNT {\n  type: ContType.NT;\n  mode: NonTerminalMode;\n  name: string;\n  asts: ASTList;\n  nt: string;\n}\nfunction contNT(\n    mode: NonTerminalMode, name: string, asts: ASTList, nt: string): ContNT {\n  return {type: ContType.NT, mode, name, asts, nt};\n}\n\ntype MatchResult = Accepted|Rejected;\n\nconst enum MatchResultType {\n  ACCEPT = 1,\n  REJECT,\n}\n\ninterface Accepted {\n  type: MatchResultType.ACCEPT;\n  pos: number;\n  asts: ASTList;\n  err: RawError;\n}\n\nfunction accept(pos: number, asts: ASTList, err: RawError): Accepted {\n  return {type: MatchResultType.ACCEPT, pos, asts, err};\n}\n\ninterface Rejected {\n  type: MatchResultType.REJECT;\n  err: RawError;\n}\n\nfunction reject(err: RawError): Rejected {\n  return {type: MatchResultType.REJECT, err};\n}\n\nconst enum ActionType {\n  EVAL = 1,\n  APPLY,\n}\n\ninterface ActionEval {\n  type: ActionType.EVAL;\n  exp: RuntimeExpr;\n  pos: number;\n  asts: ASTList;\n  err: RawError;\n  continuations: ConsList<Continuation>;\n}\n\nfunction evalNext(\n    exp: RuntimeExpr, pos: number, asts: ASTList, err: RawError,\n    continuations: ConsList<Continuation>): ActionEval {\n  return {type: ActionType.EVAL, asts, continuations, err, exp, pos};\n}\n\ninterface ActionApply {\n  type: ActionType.APPLY;\n  continuations: ConsList<Continuation>;\n  value: MatchResult;\n}\n\nfunction applyNext(\n    continuations: ConsList<Continuation>, value: MatchResult): ActionApply {\n  return {type: ActionType.APPLY, continuations, value};\n}\n\nfunction match(\n    env: RuntimeParserConfig, start: keyof ParserConfig, input: string): AST|\n    ParseError {\n  // move from initial state to halting state\n  let action = moveEval(\n      env, input,\n      evalNext(\n          env[start].exp, /*pos=*/0, /*asts=*/empty(),\n          new RawError(\n              /*pos=*/0, /*nonterminals=*/cons(start, empty()),\n              /*failedChars=*/empty(),\n              /*currentNT=*/start),\n          /*continuations=*/empty()));\n  while (true) {\n    switch (action.type) {\n      case ActionType.EVAL:\n        action = moveEval(env, input, action);\n        break;\n      case ActionType.APPLY:\n        const {continuations, value} = action;\n        if (continuations.isEmpty()) {\n          return moveReturn(env, start, input, value);\n        }\n        action =\n            moveApply(input, value, continuations.head, continuations.tail);\n        break;\n    }\n  }\n}\n\n// Evaluates the result of the expression given in `action`.\nfunction moveEval(env: RuntimeParserConfig, input: string, action: ActionEval):\n    ActionEval|ActionApply {\n  const {exp, pos, asts, err, continuations} = action;\n  const eof = pos >= input.length;\n  switch (exp.type) {\n    case ExprType.ANY_CHAR:\n      if (eof) {\n        return applyNext(\n            continuations, reject(updateError(err, pos, new ErrAny())));\n      } else {\n        // Advance one position if the input code-point is in BMP, two positions\n        // otherwise.\n        return applyNext(\n            continuations,\n            isSingleCharCodepoint(codePointAtOrFail(input, pos)) ?\n                accept(pos + 1, cons(input[pos], asts), err) :\n                // A non single-char code-point implies !eof(pos + 1)\n                accept(pos + 2, cons(input[pos] + input[pos + 1], asts), err));\n      }\n    case ExprType.ALT: {\n      const {exprs} = exp;\n      if (exprs.isEmpty()) {\n        return applyNext(continuations, reject(err));\n      }\n      return evalNext(\n          exprs.head, pos, asts, err,\n          cons(contAlt(exprs.tail, pos, asts), continuations));\n    }\n    case ExprType.AND:\n      return evalNext(\n          exp.expr, pos, /*asts=*/empty(), err,\n          cons(contAnd(pos, asts, err), continuations));\n    case ExprType.NOT:\n      return evalNext(\n          exp.expr, pos, /*asts=*/empty(), err,\n          cons(contNot(pos, asts, err), continuations));\n    case ExprType.VOID:\n      return evalNext(\n          exp.expr, pos, /*asts=*/empty(), err,\n          cons(contVoid(asts), continuations));\n    case ExprType.CHAR:\n      const c = exp.char;\n      return applyNext(\n          continuations,\n          c.length === 1 ?\n              eof || c !== input[pos] ?\n              reject(updateError(err, pos, new ErrChar(c))) :\n              accept(pos + 1, cons(input[pos], asts), err) :\n              // c.length === 2:\n              pos + 1 >= input.length || c[0] !== input[pos] ||\n                      c[1] !== input[pos + 1] ?\n              reject(updateError(err, pos, new ErrChar(c))) :\n              accept(pos + 2, cons(input[pos] + input[pos + 1], asts), err));\n    case ExprType.CHAR_CLASS:\n      const cc = exp.codepoints;\n      if (eof) {\n        return applyNext(\n            continuations, reject(updateError(err, pos, new ErrCC(cc))));\n      }\n      // JavaScript string comparison does not compare Unicode characters\n      // correctly, so we must compare codepoints. Example:\n      //   'ﬆ' > '𝌆' //=> true\n      //   'ﬆ'.codePointAt(0) > '𝌆'.codePointAt(0) //=> false\n      const inputCodePoint = codePointAtOrFail(input, pos);\n      // Loop over cc instead of recursing to avoid stack overflow on large\n      // character classes.\n      for (const charClass of cc) {\n        const isMatch = typeof charClass === 'number' ?\n            // Single character\n            charClass === inputCodePoint :\n            // Range\n            charClass[0] <= inputCodePoint && charClass[1] >= inputCodePoint;\n        if (isMatch) {\n          return applyNext(\n              continuations,\n              isSingleCharCodepoint(inputCodePoint) ?\n                  accept(pos + 1, cons(input[pos], asts), err) :\n                  accept(\n                      pos + 2, cons(input[pos] + input[pos + 1], asts), err));\n        }\n      }\n      return applyNext(\n          continuations, reject(updateError(err, pos, new ErrCC(cc))));\n    case ExprType.SEQ: {\n      // A sequence is made up of a list of expressions.\n      // We traverse the list, making sure each expression succeeds.\n      // The rest of the string returned by the expression is used\n      // as input to the next expression.\n      const {exprs} = exp;\n      if (exprs.isEmpty()) {\n        return applyNext(continuations, accept(pos, asts, err));\n      }\n      return evalNext(\n          exprs.head, pos, asts, err, cons(contSeq(exprs.tail), continuations));\n    }\n    case ExprType.PLUS:\n      return evalNext(\n          exp.expr, pos, asts, err, cons(contPlus(exp.expr), continuations));\n    case ExprType.STAR:\n      return evalNext(\n          exp.expr, pos, asts, err,\n          cons(contStar(exp.expr, pos, asts), continuations));\n    case ExprType.OPT:\n      return evalNext(\n          exp.expr, pos, asts, err, cons(contOpt(pos, asts), continuations));\n    case ExprType.NT:\n      const {name} = exp;\n      const nt = env[name];\n      return evalNext(\n          nt.exp, pos, /*asts=*/empty(),\n          new RawError(err.pos, err.nonterminals, err.failedChars, name),\n          cons(contNT(nt.mode, name, asts, err.currentNT), continuations));\n    default:\n      throw new Error(`Unsupported exp.type in exp=${\n          (exp as any).type} action=${JSON.stringify(action)}`);\n  }\n}\n\n// Handles the result of a processed continuation.\nfunction moveApply(\n    input: string, value: MatchResult, evaluated: Continuation,\n    rest: ConsList<Continuation>): ActionEval|ActionApply {\n  switch (value.type) {\n    case MatchResultType.ACCEPT:\n      return moveApplyOnAccept(input, value, evaluated, rest);\n    case MatchResultType.REJECT:\n      return moveApplyOnReject(input, value, evaluated, rest);\n  }\n}\n\n// Called after the `evaluated` continuation got accepted (matched).\nfunction moveApplyOnAccept(\n    input: string, accepted: Accepted, evaluated: Continuation,\n    rest: ConsList<Continuation>): ActionEval|ActionApply {\n  switch (evaluated.type) {\n    case ContType.SEQ: {\n      const {expressions} = evaluated;\n      if (expressions.isEmpty()) {\n        return applyNext(rest, accepted);\n      }\n      return evalNext(\n          expressions.head, accepted.pos, accepted.asts, accepted.err,\n          cons(contSeq(expressions.tail), rest));\n    }\n    case ContType.STAR:\n    case ContType.PLUS:\n      return evalNext(\n          evaluated.expression, accepted.pos, accepted.asts, accepted.err,\n          cons(\n              contStar(evaluated.expression, accepted.pos, accepted.asts),\n              rest));\n    case ContType.ALT:\n    case ContType.OPT:\n      return applyNext(rest, accepted);\n    case ContType.AND:\n      return applyNext(\n          rest, accept(evaluated.pos, evaluated.asts, evaluated.err));\n    case ContType.VOID:\n      return applyNext(\n          rest, accept(accepted.pos, evaluated.asts, accepted.err));\n    case ContType.NOT:\n      return applyNext(rest, reject(evaluated.err));\n    case ContType.NT:\n      const {mode, name, asts, nt} = evaluated;\n      const valAsts = accepted.asts;\n      const newErr = new RawError(\n          accepted.err.pos, accepted.err.nonterminals, accepted.err.failedChars,\n          nt);\n      switch (mode) {\n        case NonTerminalMode.NORMAL:\n          return applyNext(\n              rest,\n              accept(\n                  accepted.pos,\n                  cons(new AST(name, valAsts.toArray().reverse()), asts),\n                  newErr));\n        case NonTerminalMode.PRUNING:\n          if (valAsts.isEmpty()) {\n            return applyNext(rest, accept(accepted.pos, asts, newErr));\n          } else if (valAsts.tail.isEmpty()) {\n            return applyNext(\n                rest, accept(accepted.pos, cons(valAsts.head, asts), newErr));\n          } else {\n            return applyNext(\n                rest,\n                accept(\n                    accepted.pos,\n                    cons(new AST(name, valAsts.toArray().reverse()), asts),\n                    newErr));\n          }\n        case NonTerminalMode.VOIDING:\n          return applyNext(rest, accept(accepted.pos, asts, newErr));\n        default:\n          // Without this check, the TypeScript compiler doesn't\n          // realize that the outer case is also exhaustive.\n          // tslint:disable-next-line:no-unused-variable\n          const checkExhaustive: never = mode;\n          throw new Error(`Invalid mode: ${JSON.stringify(mode)}`);\n      }\n  }\n}\n\n// Called after the `evaluated` continuation got rejected (did not match).\nfunction moveApplyOnReject(\n    input: string, rejected: Rejected, evaluated: Continuation,\n    continuations: ConsList<Continuation>): ActionEval|ActionApply {\n  switch (evaluated.type) {\n    case ContType.ALT: {\n      const {expressions} = evaluated;\n      if (expressions.isEmpty()) {\n        return applyNext(continuations, rejected);\n      }\n      return evalNext(\n          expressions.head, evaluated.pos, evaluated.asts, rejected.err,\n          cons(\n              contAlt(expressions.tail, evaluated.pos, evaluated.asts),\n              continuations));\n    }\n    case ContType.SEQ:\n    case ContType.VOID:\n    case ContType.PLUS:\n      return applyNext(continuations, rejected);\n    case ContType.AND:\n      return applyNext(continuations, reject(evaluated.err));\n    case ContType.NOT:\n    case ContType.STAR:\n    case ContType.OPT:\n      return applyNext(\n          continuations, accept(evaluated.pos, evaluated.asts, rejected.err));\n    case ContType.NT:\n      const err = rejected.err;\n      return applyNext(\n          continuations,\n          reject(new RawError(\n              err.pos, err.nonterminals, err.failedChars, evaluated.nt)));\n    default:\n      // tslint:disable-next-line:no-unused-variable\n      const checkExhaustive: never = evaluated;\n      throw new Error(`Invalid continuation: ${JSON.stringify(evaluated)}`);\n  }\n}\n\n// Called after the final continuation was processed.\nfunction moveReturn(\n    env: RuntimeParserConfig, start: keyof ParserConfig, input: string,\n    value: MatchResult): AST|ParseError {\n  switch (value.type) {\n    case MatchResultType.ACCEPT:\n      const asts = value.asts;\n      if (value.pos >= input.length) {\n        switch (env[start].mode) {\n          case NonTerminalMode.NORMAL:\n            return new AST(start, asts.toArray().reverse());\n          case NonTerminalMode.PRUNING:\n            if (asts.isEmpty()) {\n              return EmptyAST();\n            } else if (asts.tail.isEmpty()) {\n              const ast = asts.head;\n              if (typeof ast === 'string') {\n                throw new Error(`Expected an AST, got a string ${\n                    JSON.stringify(ast)}, in ${value}`);\n              }\n              return ast;\n            } else {\n              return new AST(start, asts.toArray().reverse());\n            }\n          case NonTerminalMode.VOIDING:\n            return EmptyAST();\n        }\n      } else if (value.err && value.pos === value.err.pos) {\n        return new RawError(\n                   value.pos, value.err.nonterminals, value.err.failedChars, '')\n            .toParseError(input);\n      } else {\n        return new RawError(value.pos, empty(), empty(), '')\n            .toParseError(input);\n      }\n    case MatchResultType.REJECT:\n      return value.err.toParseError(input);\n  }\n}\n\nfunction getLineCol(pos: number, input: string): [number, number] {\n  let lineNumber = 1;\n  let lineStartPos = 0;\n  let newlinePos = -1;\n  // tslint:disable-next-line:no-conditional-assignment\n  while ((newlinePos = input.indexOf('\\n', lineStartPos)) !== -1 &&\n         newlinePos < pos) {\n    ++lineNumber;\n    lineStartPos = newlinePos + 1;\n  }\n  return [lineNumber, pos - lineStartPos + 1];\n}\n\n// Whether the given Unicode code-point can be represented\n// by a single JavaScript String (UTF-16) character.\nfunction isSingleCharCodepoint(codePoint: number) {\n  return codePoint <= 0xFFFF;\n}\n\nfunction codePointAtOrFail(input: string, pos: number): number {\n  const codePoint = input.codePointAt(pos);\n  if (typeof codePoint === 'undefined') {\n    throw new Error(\n        `Undefined input codepoint at ${pos} in ${JSON.stringify(input)}`);\n  }\n  return codePoint;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./waxeye.ts","// We have two representations for expression:\n// the config one, and the internal one.\n\n// The config representation is JSON-compatible.\n// The internal one is optimized for performance.\n\nimport {cons, ConsList, empty} from './cons_list';\n\nexport function exprToRuntimeExpr(expr: Expr): RuntimeExpr {\n  switch (expr.type) {\n    case ExprType.NT:\n    case ExprType.CHAR:\n    case ExprType.CHAR_CLASS:\n    case ExprType.ANY_CHAR:\n      return expr;\n    case ExprType.PLUS:\n    case ExprType.STAR:\n    case ExprType.OPT:\n    case ExprType.AND:\n    case ExprType.NOT:\n    case ExprType.VOID:\n      return {type: expr.type, expr: exprToRuntimeExpr(expr.expr)} as\n          RuntimeExpr;\n    case ExprType.ALT:\n    case ExprType.SEQ:\n      return {\n        type: expr.type,\n        exprs: expr.exprs.reduceRight(\n            (result: ConsList<RuntimeExpr>, value: Expr):\n                ConsList<RuntimeExpr> => cons(exprToRuntimeExpr(value), result),\n            empty()),\n      } as RuntimeExpr;\n  }\n}\n\nexport type Expr = NonRecursiveExpr|ExprPlus|ExprStar|ExprOpt|ExprAnd|ExprNot|\n    ExprVoid|ExprAlt|ExprSeq;\nexport type RuntimeExpr =\n    NonRecursiveExpr|RuntimeExprPlus|RuntimeExprStar|RuntimeExprOpt|\n    RuntimeExprAnd|RuntimeExprNot|RuntimeExprVoid|RuntimeExprAlt|RuntimeExprSeq;\nexport type NonRecursiveExpr =\n    ExprNonTerminal|ExprChar|ExprCharClass|ExprAnyChar;\n\nexport const enum ExprType {\n  NT = 1,\n  ALT,\n  SEQ,\n  PLUS,\n  STAR,\n  OPT,\n  AND,\n  NOT,\n  VOID,\n  ANY_CHAR,\n  CHAR,\n  CHAR_CLASS,\n}\n\nexport interface ExprNonTerminal {\n  type: ExprType.NT;\n  name: string;\n}\n\nexport interface ExprAnyChar { type: ExprType.ANY_CHAR; }\n\nexport interface ExprChar {\n  type: ExprType.CHAR;\n  // A single character (represented by a single Unicode codepoint).\n  char: string;\n}\n\nexport interface ExprCharClass {\n  type: ExprType.CHAR_CLASS;\n  // A list of Unicode codepoints / ranges of codepoints.\n  codepoints: Array<number|[number, number]>;\n}\n\nexport interface ExprAlt {\n  type: ExprType.ALT;\n  exprs: Expr[];\n}\nexport interface RuntimeExprAlt {\n  type: ExprType.ALT;\n  exprs: ConsList<RuntimeExpr>;\n}\n\nexport interface ExprSeq {\n  type: ExprType.SEQ;\n  exprs: Expr[];\n}\nexport interface RuntimeExprSeq {\n  type: ExprType.SEQ;\n  exprs: ConsList<RuntimeExpr>;\n}\n\nexport interface ExprPlus {\n  type: ExprType.PLUS;\n  expr: Expr;\n}\nexport interface RuntimeExprPlus {\n  type: ExprType.PLUS;\n  expr: RuntimeExpr;\n}\n\nexport interface ExprStar {\n  type: ExprType.STAR;\n  expr: Expr;\n}\nexport interface RuntimeExprStar {\n  type: ExprType.STAR;\n  expr: RuntimeExpr;\n}\n\nexport interface ExprOpt {\n  type: ExprType.OPT;\n  expr: Expr;\n}\nexport interface RuntimeExprOpt {\n  type: ExprType.OPT;\n  expr: RuntimeExpr;\n}\n\nexport interface ExprAnd {\n  type: ExprType.AND;\n  expr: Expr;\n}\nexport interface RuntimeExprAnd {\n  type: ExprType.AND;\n  expr: RuntimeExpr;\n}\n\nexport interface ExprNot {\n  type: ExprType.NOT;\n  expr: Expr;\n}\nexport interface RuntimeExprNot {\n  type: ExprType.NOT;\n  expr: RuntimeExpr;\n}\n\nexport interface ExprVoid {\n  type: ExprType.VOID;\n  expr: Expr;\n}\nexport interface RuntimeExprVoid {\n  type: ExprType.VOID;\n  expr: RuntimeExpr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./expr.ts"],"sourceRoot":""}