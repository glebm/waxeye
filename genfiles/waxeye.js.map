{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap a7e1da38d4da6cee5c71","webpack:///./waxeye.ts"],"names":[],"mappings":"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","file":"./dist/waxeye.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"waxeye\"] = factory();\n\telse\n\t\troot[\"waxeye\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a7e1da38d4da6cee5c71","/*\n * Waxeye Parser Generator http://www.waxeye.org\n * Licensed under the MIT license. See 'LICENSE' for details.\n */\n\nexport class WaxeyeParser {\n  public constructor(\n      public env: ParserConfig,\n      public start: keyof ParserConfig /* keyof env */) {}\n\n  public parse(input: string, start: string = this.start): AST|ParseError {\n    if (!this.env[start]) {\n      throw new Error(`Invalid non-terminal ${start}. Expected one of: ${\n          Object.keys(this.env).join(', ')}`);\n    }\n    return match(this.env, start, input);\n  }\n}\n\nexport interface ParserConfig {\n  // name -> NonTerminal\n  [key: string]: NonTerminal;\n}\n\nexport interface NonTerminal {\n  mode: NonTerminalMode;\n  exp: Expr;\n}\n\nexport const enum NonTerminalMode {\n  NORMAL = 1,\n  PRUNING,\n  VOIDING,\n}\n\n/*\n * An abstract syntax tree holds the non-terminal's name (`type`),\n * and a list of child ASTs.\n */\nexport class AST {\n  constructor(public type: string, public children: Array<AST|string>) {}\n\n  /**\n   * The empty AST is an AST that has an empty `type` and no children.\n   */\n  public isEmpty(): this is EmptyAST {\n    return this.type === '' && this.children.length === 0;\n  }\n}\n\nexport interface EmptyAST extends AST {\n  type: '';\n  children: never[];\n}\n\nexport function EmptyAST(): EmptyAST {\n  return new AST('', []) as EmptyAST;\n}\n\nexport type Expr = ExprNonTerminal|ExprAlt|ExprSeq|ExprPlus|ExprStar|ExprOpt|\n    ExprAnd|ExprNot|ExprVoid|ExprAny|ExprChar|ExprCharClass;\n\nexport const enum ExprType {\n  NT = 1,\n  ALT,\n  SEQ,\n  PLUS,\n  STAR,\n  OPT,\n  AND,\n  NOT,\n  VOID,\n  ANY,\n  CHAR,\n  CHAR_CLASS,\n}\n\nexport interface ExprNonTerminal {\n  type: ExprType.NT;\n  // Non-terminal's name.\n  args: [string];\n}\nexport interface ExprAlt {\n  type: ExprType.ALT;\n  args: Expr[];\n}\nexport interface ExprSeq {\n  type: ExprType.SEQ;\n  args: Expr[];\n}\nexport interface ExprPlus {\n  type: ExprType.PLUS;\n  args: [Expr];\n}\nexport interface ExprStar {\n  type: ExprType.STAR;\n  args: [Expr];\n}\nexport interface ExprOpt {\n  type: ExprType.OPT;\n  args: [Expr];\n}\nexport interface ExprAnd {\n  type: ExprType.AND;\n  args: [Expr];\n}\nexport interface ExprNot {\n  type: ExprType.NOT;\n  args: [Expr];\n}\nexport interface ExprVoid {\n  type: ExprType.VOID;\n  args: [Expr];\n}\nexport interface ExprAny {\n  type: ExprType.ANY;\n  args: never[];\n}\nexport interface ExprChar {\n  type: ExprType.CHAR;\n  // A single character (represented by a single Unicode codepoint).\n  args: [string];\n}\nexport interface ExprCharClass {\n  type: ExprType.CHAR_CLASS;\n  // A list of Unicode codepoints / ranges of codepoints.\n  args: Array<number|[number, number]>;\n}\n\nexport interface MatchError {\n  // Expected expression in the grammar format.\n  toGrammarString(): string;\n}\n\n// A failed single character match.\nexport class ErrChar implements MatchError {\n  constructor(public char: string) {}\n\n  public toGrammarString() {\n    return `'${JSON.stringify(this.char).slice(1, -1)}'`;\n  }\n}\n\n// A failed character class match.\nexport class ErrCC implements MatchError {\n  // A list of Unicode codepoints / ranges of codepoints.\n  constructor(public charClasses: Array<number|[number, number]>) {}\n\n  public toGrammarString() {\n    return `[${\n        this.charClasses\n            .map((charClass) => {\n              return JSON\n                  .stringify(\n                      typeof charClass === 'number' ?\n                          String.fromCodePoint(charClass) :\n                          `${String.fromCodePoint(charClass[0])}-${\n                              String.fromCodePoint(charClass[1])}`)\n                  .slice(1, -1);\n            })\n            .join('')}]`;\n  }\n}\n\n// A failed wildcard match.\nexport class ErrAny implements MatchError {\n  public toGrammarString() {\n    return '.';\n  }\n}\n\nexport class ParseError {\n  constructor(\n      public pos: number, public line: number, public col: number,\n      public nt: string[], public chars: MatchError[]) {}\n\n  public toString(): string {\n    let chars;\n    chars = this.chars.map((err) => err.toGrammarString()).join(' | ');\n    if (chars === '') {\n      chars = '\\'\\'';\n    }\n    return `Parse error: Failed to match '${this.nt.join(',')}' at line=${\n        this.line}, col=${this.col}, pos=${this.pos}. Expected: ${chars}`;\n  }\n}\nclass RawError {\n  constructor(\n      public pos: number, public nonterminals: string[],\n      public failedChars: MatchError[], public currentNT: string) {}\n\n  public toParseError(input: string): ParseError {\n    const [line, col] = getLineCol(this.pos, input);\n    const uniqueNonterminals: string[] = [];\n    const seenNonterminals = new Set<string>();\n    for (const nt of this.nonterminals) {\n      if (seenNonterminals.has(nt)) {\n        continue;\n      }\n      uniqueNonterminals.push(nt);\n      seenNonterminals.add(nt);\n    }\n    return new ParseError(\n        this.pos, line, col, uniqueNonterminals, this.failedChars.reverse());\n  }\n}\n\nfunction updateError(err: RawError, pos: number, e: MatchError): RawError {\n  if (err !== null) {\n    if (pos > err.pos) {\n      return new RawError(pos, [err.currentNT], [e], err.currentNT);\n    } else if (pos === err.pos) {\n      return new RawError(\n          err.pos, [err.currentNT, ...err.nonterminals],\n          [e, ...err.failedChars], err.currentNT);\n    } else {\n      return new RawError(\n          err.pos, err.nonterminals, err.failedChars, err.currentNT);\n    }\n  } else {\n    return new RawError(0, [''], [e], '');\n  }\n}\n\ntype Continuation =\n    ContSeq|ContAlt|ContAnd|ContNot|ContOpt|ContStar|ContPlus|ContVoid|ContNT;\n\nconst enum ContType {\n  SEQ = 1,\n  ALT,\n  AND,\n  NOT,\n  OPT,\n  STAR,\n  PLUS,\n  VOID,\n  NT,\n}\n\ninterface ContSeq {\n  type: ContType.SEQ;\n  expressions: Expr[];\n}\nfunction contSeq(expressions: Expr[]): ContSeq {\n  return {type: ContType.SEQ, expressions};\n}\n\ninterface ContAlt {\n  type: ContType.ALT;\n  expressions: Expr[];\n  pos: number;\n  asts: Array<string|AST>;\n}\nfunction contAlt(\n    expressions: Expr[], pos: number, asts: Array<string|AST>): ContAlt {\n  return {type: ContType.ALT, expressions, pos, asts};\n}\n\ninterface ContAnd {\n  type: ContType.AND;\n  pos: number;\n  asts: Array<string|AST>;\n  err: RawError;\n}\nfunction contAnd(pos: number, asts: Array<string|AST>, err: RawError): ContAnd {\n  return {type: ContType.AND, pos, asts, err};\n}\n\ninterface ContNot {\n  type: ContType.NOT;\n  pos: number;\n  asts: Array<string|AST>;\n  err: RawError;\n}\nfunction contNot(pos: number, asts: Array<string|AST>, err: RawError): ContNot {\n  return {type: ContType.NOT, pos, asts, err};\n}\n\ninterface ContOpt {\n  type: ContType.OPT;\n  pos: number;\n  asts: Array<string|AST>;\n}\nfunction contOpt(pos: number, asts: Array<string|AST>): ContOpt {\n  return {type: ContType.OPT, pos, asts};\n}\n\ninterface ContStar {\n  type: ContType.STAR;\n  expression: Expr;\n  pos: number;\n  asts: Array<string|AST>;\n}\nfunction contStar(\n    expression: Expr, pos: number, asts: Array<string|AST>): ContStar {\n  return {type: ContType.STAR, expression, pos, asts};\n}\n\ninterface ContPlus {\n  type: ContType.PLUS;\n  expression: Expr;\n}\nfunction contPlus(expression: Expr): ContPlus {\n  return {type: ContType.PLUS, expression};\n}\n\ninterface ContVoid {\n  type: ContType.VOID;\n  asts: Array<string|AST>;\n}\nfunction contVoid(asts: Array<string|AST>): ContVoid {\n  return {type: ContType.VOID, asts};\n}\n\ninterface ContNT {\n  type: ContType.NT;\n  mode: NonTerminalMode;\n  name: string;\n  asts: Array<string|AST>;\n  nt: string;\n}\nfunction contNT(\n    mode: NonTerminalMode, name: string, asts: Array<string|AST>,\n    nt: string): ContNT {\n  return {type: ContType.NT, mode, name, asts, nt};\n}\n\ntype MatchResult = Accepted|Rejected;\n\nconst enum MatchResultType {\n  ACCEPT = 1,\n  REJECT,\n}\n\ninterface Accepted {\n  type: MatchResultType.ACCEPT;\n  pos: number;\n  asts: Array<AST|string>;\n  err: RawError;\n}\n\nfunction accept(pos: number, asts: Array<AST|string>, err: RawError): Accepted {\n  return {type: MatchResultType.ACCEPT, pos, asts, err};\n}\n\ninterface Rejected {\n  type: MatchResultType.REJECT;\n  err: RawError;\n}\n\nfunction reject(err: RawError): Rejected {\n  return {type: MatchResultType.REJECT, err};\n}\n\ntype Action = ActionEval|ActionApply|ActionReturn;\n\nconst enum ActionType {\n  EVAL = 1,\n  APPLY,\n  RETURN,\n}\n\ninterface ActionEval {\n  type: ActionType.EVAL;\n  exp: Expr;\n  pos: number;\n  asts: Array<AST|string>;\n  err: RawError;\n  continuations: Continuation[];\n}\n\nfunction evalNext(\n    exp: Expr, pos: number, asts: Array<AST|string>, err: RawError,\n    continuations: Continuation[]): ActionEval {\n  return {type: ActionType.EVAL, asts, continuations, err, exp, pos};\n}\n\ninterface ActionApply {\n  type: ActionType.APPLY;\n  continuations: Continuation[];\n  value: MatchResult;\n}\n\nfunction applyNext(\n    continuations: Continuation[], value: MatchResult): ActionApply {\n  return {type: ActionType.APPLY, continuations, value};\n}\n\ninterface ActionReturn {\n  type: ActionType.RETURN;\n  result: AST|ParseError;\n}\n\nfunction returnNext(result: AST|ParseError): ActionReturn {\n  return {type: ActionType.RETURN, result};\n}\n\nfunction match(env: ParserConfig, start: keyof ParserConfig, input: string):\n    AST|ParseError {\n  // move from initial state to halting state\n  let action = move(\n      env, start, input,\n      evalNext(env[start].exp, 0, [], new RawError(0, [start], [], start), []));\n  while (action.type !== ActionType.RETURN) {\n    action = move(env, start, input, action);\n  }\n  return action.result;\n}\n\nfunction move(\n    env: ParserConfig, start: keyof ParserConfig, input: string,\n    conf: ActionEval|ActionApply): Action {\n  switch (conf.type) {\n    case ActionType.EVAL:\n      return moveEval(env, input, conf);\n    case ActionType.APPLY:\n      const {continuations, value} = conf;\n      if (continuations.length === 0) {\n        return moveReturn(env, start, input, value);\n      }\n      const [evaluated, ...rest] = continuations;\n      return moveApply(env, input, value, evaluated, rest);\n  }\n}\n\n// Evaluates the result of the expression given in `conf`.\nfunction moveEval(env: ParserConfig, input: string, conf: ActionEval):\n    ActionEval|ActionApply {\n  const {exp, pos, asts, err, continuations} = conf;\n  const eof = pos >= input.length;\n  switch (exp.type) {\n    case ExprType.ANY:\n      if (eof) {\n        return applyNext(\n            continuations, reject(updateError(err, pos, new ErrAny())));\n      } else {\n        // Advance one position if the input code-point is in BMP, two positions\n        // otherwise.\n        return applyNext(\n            continuations,\n            isSingleCharCodepoint(codePointAtOrFail(input, pos)) ?\n                accept(pos + 1, [input[pos], ...asts], err) :\n                // A non single-char code-point implies !eof(pos + 1)\n                accept(pos + 2, [input[pos] + input[pos + 1], ...asts], err));\n      }\n    case ExprType.ALT:\n      const es = exp.args;\n      if (es.length > 0) {\n        return evalNext(\n            es[0], pos, asts, err,\n            [contAlt(es.slice(1), pos, asts), ...continuations]);\n      } else {\n        return applyNext(continuations, reject(err));\n      }\n    case ExprType.AND:\n      return evalNext(\n          exp.args[0], pos, [], err,\n          [contAnd(pos, asts, err), ...continuations]);\n    case ExprType.NOT:\n      return evalNext(\n          exp.args[0], pos, [], err,\n          [contNot(pos, asts, err), ...continuations]);\n    case ExprType.VOID:\n      return evalNext(\n          exp.args[0], pos, [], err, [contVoid(asts), ...continuations]);\n    case ExprType.CHAR:\n      const c = exp.args[0];\n      return applyNext(\n          continuations,\n          c.length === 1 ?\n              eof || c !== input[pos] ?\n              reject(updateError(err, pos, new ErrChar(c))) :\n              accept(pos + 1, [input[pos], ...asts], err) :\n              // c.length === 2:\n              pos + 1 >= input.length || c[0] !== input[pos] ||\n                      c[1] !== input[pos + 1] ?\n              reject(updateError(err, pos, new ErrChar(c))) :\n              accept(pos + 2, [input[pos] + input[pos + 1], ...asts], err));\n    case ExprType.CHAR_CLASS:\n      const cc = exp.args;\n      if (eof) {\n        return applyNext(\n            continuations, reject(updateError(err, pos, new ErrCC(cc))));\n      }\n      // JavaScript string comparison does not compare Unicode characters\n      // correctly, so we must compare codepoints. Example:\n      //   'ﬆ' > '𝌆' //=> true\n      //   'ﬆ'.codePointAt(0) > '𝌆'.codePointAt(0) //=> false\n      const inputCodePoint = codePointAtOrFail(input, pos);\n      // Loop over cc instead of recursing to avoid stack overflow on large\n      // character classes.\n      for (const charClass of cc) {\n        const isMatch = typeof charClass === 'number' ?\n            // Single character\n            charClass === inputCodePoint :\n            // Range\n            charClass[0] <= inputCodePoint && charClass[1] >= inputCodePoint;\n        if (isMatch) {\n          return applyNext(\n              continuations,\n              isSingleCharCodepoint(inputCodePoint) ?\n                  accept(pos + 1, [input[pos], ...asts], err) :\n                  accept(pos + 2, [input[pos] + input[pos + 1], ...asts], err));\n        }\n      }\n      return applyNext(\n          continuations, reject(updateError(err, pos, new ErrCC(cc))));\n    case ExprType.SEQ:\n      // A sequence is made up of a list of expressions.\n      // We traverse the list, making sure each expression succeeds.\n      // The rest of the string returned by the expression is used\n      // as input to the next expression.\n      const exprs = exp.args;\n      if (exprs.length === 0) {\n        return applyNext(continuations, accept(pos, asts, err));\n      } else {\n        return evalNext(\n            exprs[0], pos, asts, err,\n            [contSeq(exprs.slice(1)), ...continuations]);\n      }\n    case ExprType.PLUS:\n      return evalNext(\n          exp.args[0], pos, asts, err,\n          [contPlus(exp.args[0]), ...continuations]);\n    case ExprType.STAR:\n      return evalNext(\n          exp.args[0], pos, asts, err,\n          [contStar(exp.args[0], pos, asts), ...continuations]);\n    case ExprType.OPT:\n      return evalNext(\n          exp.args[0], pos, asts, err, [contOpt(pos, asts), ...continuations]);\n    case ExprType.NT:\n      const name = exp.args[0];\n      const nt = env[name];\n      return evalNext(\n          nt.exp, pos, [],\n          new RawError(err.pos, err.nonterminals, err.failedChars, name),\n          [contNT(nt.mode, name, asts, conf.err.currentNT), ...continuations]);\n    default:\n      throw new Error(`Unsupported exp.type in exp=${(exp as any).type} conf=${\n          JSON.stringify(conf)}`);\n  }\n}\n\n// Handles the result of a processed continuation.\nfunction moveApply(\n    env: ParserConfig, input: string, value: MatchResult,\n    evaluated: Continuation, rest: Continuation[]): ActionEval|ActionApply {\n  switch (value.type) {\n    case MatchResultType.ACCEPT:\n      return moveApplyOnAccept(env, input, value, evaluated, rest);\n    case MatchResultType.REJECT:\n      return moveApplyOnReject(env, input, value, evaluated, rest);\n  }\n}\n\n// Called after the `evaluated` continuation got accepted (matched).\nfunction moveApplyOnAccept(\n    env: ParserConfig, input: string, accepted: Accepted,\n    evaluated: Continuation, rest: Continuation[]): ActionEval|ActionApply {\n  switch (evaluated.type) {\n    case ContType.SEQ:\n      const es = evaluated.expressions;\n      if (es.length > 0) {\n        return evalNext(\n            es[0], accepted.pos, accepted.asts, accepted.err,\n            [contSeq(es.slice(1)), ...rest]);\n      } else {\n        return applyNext(rest, accepted);\n      }\n    case ContType.STAR:\n    case ContType.PLUS:\n      return evalNext(\n          evaluated.expression, accepted.pos, accepted.asts, accepted.err, [\n            contStar(evaluated.expression, accepted.pos, accepted.asts),\n            ...rest,\n          ]);\n    case ContType.ALT:\n    case ContType.OPT:\n      return applyNext(rest, accepted);\n    case ContType.AND:\n      return applyNext(\n          rest, accept(evaluated.pos, evaluated.asts, evaluated.err));\n    case ContType.VOID:\n      return applyNext(\n          rest, accept(accepted.pos, evaluated.asts, accepted.err));\n    case ContType.NOT:\n      return applyNext(rest, reject(evaluated.err));\n    case ContType.NT:\n      const {mode, name, asts, nt} = evaluated;\n      const valAsts = accepted.asts;\n      const newErr = new RawError(\n          accepted.err.pos, accepted.err.nonterminals, accepted.err.failedChars,\n          nt);\n      switch (mode) {\n        case NonTerminalMode.NORMAL:\n          return applyNext(\n              rest,\n              accept(\n                  accepted.pos, [new AST(name, valAsts.reverse()), ...asts],\n                  newErr));\n        case NonTerminalMode.PRUNING:\n          switch (valAsts.length) {\n            case 0:\n              return applyNext(rest, accept(accepted.pos, asts, newErr));\n            case 1:\n              return applyNext(\n                  rest, accept(accepted.pos, [valAsts[0], ...asts], newErr));\n            default:\n              return applyNext(\n                  rest,\n                  accept(\n                      accepted.pos, [new AST(name, valAsts.reverse()), ...asts],\n                      newErr));\n          }\n        case NonTerminalMode.VOIDING:\n          return applyNext(rest, accept(accepted.pos, asts, newErr));\n        default:\n          // Without this check, the TypeScript compiler doesn't\n          // realize that the outer case is also exhaustive.\n          const checkExhaustive: never = mode;\n          throw new Error(`Invalid mode: ${JSON.stringify(mode)}`);\n      }\n  }\n}\n\n// Called after the `evaluated` continuation got rejected (did not match).\nfunction moveApplyOnReject(\n    env: ParserConfig, input: string, rejected: Rejected,\n    evaluated: Continuation, continuations: Continuation[]): ActionEval|\n    ActionApply {\n  switch (evaluated.type) {\n    case ContType.ALT:\n      const es = evaluated.expressions;\n      if (es.length > 0) {\n        return evalNext(es[0], evaluated.pos, evaluated.asts, rejected.err, [\n          contAlt(es.slice(1), evaluated.pos, evaluated.asts),\n          ...continuations,\n        ]);\n      } else {\n        return applyNext(continuations, rejected);\n      }\n    case ContType.SEQ:\n    case ContType.VOID:\n    case ContType.PLUS:\n      return applyNext(continuations, rejected);\n    case ContType.AND:\n      return applyNext(continuations, reject(evaluated.err));\n    case ContType.NOT:\n    case ContType.STAR:\n    case ContType.OPT:\n      return applyNext(\n          continuations, accept(evaluated.pos, evaluated.asts, rejected.err));\n    case ContType.NT:\n      const err = rejected.err;\n      return applyNext(\n          continuations,\n          reject(new RawError(\n              err.pos, err.nonterminals, err.failedChars, evaluated.nt)));\n    default:\n      const checkExhaustive: never = evaluated;\n      throw new Error(`Invalid continuation: ${JSON.stringify(evaluated)}`);\n  }\n}\n\n// Called after the final continuation was processed.\nfunction moveReturn(\n    env: ParserConfig, start: keyof ParserConfig, input: string,\n    value: MatchResult): ActionReturn {\n  switch (value.type) {\n    case MatchResultType.ACCEPT:\n      const asts = value.asts;\n      if (value.pos >= input.length) {\n        switch (env[start].mode) {\n          case NonTerminalMode.NORMAL:\n            return returnNext(new AST(start, asts.reverse()));\n          case NonTerminalMode.PRUNING:\n            switch (asts.length) {\n              case 0:\n                return returnNext(EmptyAST());\n              case 1:\n                const ast = asts[0];\n                if (typeof ast === 'string') {\n                  throw new Error(`Expected an AST, got a string ${\n                      JSON.stringify(ast)}, in ${value}`);\n                }\n                return returnNext(ast);\n              default:\n                return returnNext(new AST(start, asts.reverse()));\n            }\n          case NonTerminalMode.VOIDING:\n            return returnNext(EmptyAST());\n        }\n      } else if (value.err && value.pos === value.err.pos) {\n        return returnNext(\n            (new RawError(\n                 value.pos, value.err.nonterminals, value.err.failedChars, ''))\n                .toParseError(input));\n      } else {\n        return returnNext(\n            (new RawError(value.pos, [], [], '')).toParseError(input));\n      }\n    case MatchResultType.REJECT:\n      return returnNext(value.err.toParseError(input));\n  }\n}\n\nfunction getLineCol(pos: number, input: string): [number, number] {\n  let lineNumber = 1;\n  let lineStartPos = 0;\n  let newlinePos = -1;\n  // tslint:disable-next-line:no-conditional-assignment\n  while ((newlinePos = input.indexOf('\\n', lineStartPos)) !== -1 &&\n         newlinePos < pos) {\n    ++lineNumber;\n    lineStartPos = newlinePos + 1;\n  }\n  return [lineNumber, pos - lineStartPos + 1];\n}\n\n// Whether the given Unicode code-point can be represented\n// by a single JavaScript String (UTF-16) character.\nfunction isSingleCharCodepoint(codePoint: number) {\n  return codePoint <= 0xFFFF;\n}\n\nfunction codePointAtOrFail(input: string, pos: number): number {\n  const codePoint = input.codePointAt(pos);\n  if (typeof codePoint === 'undefined') {\n    throw new Error(\n        `Undefined input codepoint at ${pos} in ${JSON.stringify(input)}`);\n  }\n  return codePoint;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./waxeye.ts"],"sourceRoot":""}